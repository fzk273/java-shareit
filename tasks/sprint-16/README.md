# Проект ShareIt. Техническое задание. Часть 3

Ваш проект ShareIt уже работает и приносит пользу. Осталось реализовать последнюю запланированную функциональность:
возможность создавать запрос вещи и добавлять вещи в ответ на запросы других пользователей. Тогда приложение станет
максимально функциональным и удобным.

Но это ещё не всё, что вам предстоит сделать в этом спринте. Пользователей приложения ShareIt становится больше. Вы рады
этому, но замечаете, что не всё идёт гладко: приложение работает медленнее, пользователи чаще жалуются, что их запросы
подолгу остаются без ответа.

После небольшого самостоятельного исследования вы начинаете понимать, в чём дело. Пользователи учатся программировать —
совсем так же, как и вы! Некоторые из них теперь используют ваше приложение через другие программы: собственноручно
написанные интерфейсы, боты… Чего они только не придумали!

Не все эти программы работают правильно. В ShareIt поступает много некорректных запросов — например, с невалидными
входными данными, в неверном формате или просто дублей. Ваше приложение тратит ресурсы на обработку каждого из запросов,
и в результате его работа замедляется. Пришло время разобраться с этим!

## Добавляем запрос вещи

В этом спринте разработка будет вестись в ветке add-item-requests-and-gateway. Начнём с первой большой задачи — с
запросов на добавление вещи.

Пользователь создаёт запрос на добавление вещи в том случае, если не может найти нужную вещь с помощью поиска. Но при
этом надеется, что у кого-то она всё же имеется. Другие пользователи могут просматривать такие запросы. Если у них есть
описанная вещь и они готовы предоставить её в аренду, они смогут добавить её в ответ на запрос.

Вам нужно реализовать четыре новых эндпоинта:

* POST /requests — добавить новый запрос вещи.
  Основная часть запроса — текст запроса, в котором пользователь описывает, какая именно вещь ему нужна.
* GET /requests — получить список своих запросов вместе с данными об ответах на них.
  Для каждого запроса должны быть указаны описание, дата и время создания, а также список ответов в формате: id вещи,
  название, id владельца. В дальнейшем, используя указанные id вещей, можно будет получить подробную информацию о каждой
  из них. Запросы должны возвращаться отсортированными от более новых к более старым.
* GET /requests/all — получить список запросов, созданных другими пользователями.
  С помощью этого эндпоинта пользователи смогут просматривать существующие запросы, на которые они могли бы ответить.
  Запросы сортируются по дате создания от более новых к более старым.
* GET /requests/{requestId} — получить данные об одном конкретном запросе вместе с данными об ответах на него в том же
  формате, что и в эндпоинте GET /requests. Посмотреть данные об отдельном запросе может любой пользователь.

## Добавляем опцию ответа на запрос

Реализуйте ещё одну полезную опцию в вашем приложении, чтобы пользователи смогли отвечать на запросы друг друга. Для
этого при создании вещи должна быть возможность указать id запроса, в ответ на который создаётся нужная вещь.

Добавьте поле requestId в тело запроса POST /items. Обратите внимание: должна сохраниться возможность добавить вещь и
без указания requestId.

Реализуйте соответствующие эндпоинты.

## Выделяем валидацию в отдельный сервис

Теперь можно переходить к следующей большой задаче — разобраться с некорректными запросами!

В реальной разработке для решения таких проблем часто применяют микросервисную архитектуру. Можно вынести часть
приложения, с которой непосредственно работают пользователи, в отдельное небольшое приложение и назвать его, допустим,
gateway (англ. «шлюз»). В нём будет выполняться вся валидация запросов — некорректные будут исключаться.

Поскольку для этой части работы не требуется базы данных и каких-то особых ресурсов, приложение gateway будет
легковесным. При необходимости его можно будет легко масштабировать. Например, вместо одного экземпляра gateway можно
запустить целых три — чтобы справиться с потоком запросов от пользователей.

После валидации в gateway запрос будет отправлен основному приложению, которое делает всю реальную работу — в том числе
обращается к базе данных. Также на стороне gateway может быть реализовано кэширование: например, если один и тот же
запрос придёт два раза подряд, gateway будет самостоятельно возвращать предыдущий ответ без обращения к основному
приложению.

## Формулируем задачу конкретнее

Ваша задача разбить приложение ShareIt на два — shareIt-server и shareIt-gateway:

* shareIt-server будет содержать всю основную логику и почти полностью повторять приложение, с которым вы работали
  ранее. За исключением того, что можно будет убрать валидацию данных в контроллерах.
* В shareIt-gateway нужно вынести контроллеры, с которыми непосредственно работают пользователи, и всю валидацию входных
  данных — кроме той, которая требует работы с БД.

Каждое из приложений будет запускаться как самостоятельное Java-приложение, а их общение будет происходить через REST.

Чтобы оба приложения смогли одновременно работать на одной машине, они должны использовать разные сетевые порты. Для
shareIt-gateway оставьте порт прежним — $8080$. Тогда его не нужно будет менять в запросах, сохранённых в коллекции
Postman. А для shareIt-server измените порт на $9090$ с помощью свойства server.port=9090.

## Ещё несколько технических моментов

Вам нужно разбить одно приложение ShareIt на два так, чтобы оба остались в том же репозитории и собирались одной
Maven-командой. Реализовать подобный механизм в Maven помогают многомодульные проекты (англ. multi-module project).
Такие проекты содержат в себе несколько более мелких подпроектов.

В нашем случае каждый из подпроектов будет представлять собой самостоятельное Java-приложение. Вообще же подпроект может
содержать любой набор кода или других сущностей, которые собираются с помощью Maven. Это может быть, например, набор
статических ресурсов — HTML-файлы, изображения и так далее.

Многомодульный проект содержит один родительский pom-файл для всего проекта. В нём перечисляются все модули или
подпроекты. Также для каждого из модулей создаётся собственный pom-файл со всей информацией о сборке отдельного модуля.
Когда в корневой директории проекта запустится команда сборки (например, mvn clean install), Maven соберёт каждый из
модулей и положит результирующий jar-файл в директорию target соответствующего модуля.

Подробнее о том, как работать с многомодульными проектами, вы можете узнать из
этого [ресурса](https://spring.io/guides/gs/multi-module).

Мы уже подготовили для вас шаблон многомодульного проекта — ищите его в ветке add-item-requests-and-gateway. Всё, что
остаётся сделать, — распределить код вашего приложения между модулями, а также добавить в shareIt-gateway код для
обращения к shareIt-server через REST.

Чтобы вам было проще работать с REST, мы создали в shareIt-gateway класс BaseClient, который реализует базовый механизм
взаимодействия через REST. Вы можете использовать и дорабатывать этот класс по своему усмотрению.

Также в качестве примера мы создали класс BookingClient, наследующий от BaseClient и содержащий операции для работы с
бронированиями. А ещё класс BookingCotroller — он содержит пример реализации некоторых конечных эндпоинтов, с которыми
будут работать пользователи.

Ещё больше деталей для работы с REST-вызовами вы найдёте [по ссылке](https://www.baeldung.com/rest-template)

Убедитесь, что ваше приложения успешно запускаются и пользователи, как и прежде, могут создавать и бронировать вещи.

## Тестирование

И наконец, ещё одна важная задача этого спринта — написать тесты для приложения ShareIt. Не оставляйте эту задачу на
конец работы. Делайте всё постепенно: перед тем как реализовать какую-либо часть задания, сформулируйте функциональные и
нефункциональные требования к ней. В соответствии с этими требованиями напишите реализацию. Затем напишите юнит-тесты,
проверяющие реализацию на соответствие требованиям.

После того как будут написаны тесты для новой функциональности, описанной в этом техническом задании, переходите к
написанию тестов для тех возможностей, что были реализованы в предыдущих спринтах.

В реальной практике программисты пишут тесты параллельно с новым кодом. Так каждая функциональность, которую они
разрабатывают, изначально покрывается тестами.

При написании тестов вам предстоит решить несколько задач:

* Реализовать интеграционные тесты, которые проверяют взаимодействие с базой данных. Как вы помните, интеграционные
  тесты представляют собой более высокий уровень тестирования: их обычно требуется меньше, но покрытие каждого — больше.
  Мы предлагаем вам создать по одному интеграционному тесту для каждого крупного метода в ваших сервисах. Например, для
  метода getUserItems в классе ItemServiceImpl.
* Реализовать тесты для REST-эндпоинтов вашего приложения с использованием MockMVC. Вам нужно покрыть тестами все
  существующие эндпоинты. При этом для слоя сервисов используйте моки.
* Реализовать тесты для работы с JSON для DTO в вашем приложении с помощью аннотации @JsonTest. Такие тесты имеют смысл
  в тех случаях, когда ваши DTO содержат в себе некоторую логику. Например, описание формата дат или валидацию. Выберите
  DTO, где есть подобные условия, и напишите тесты.

Для проверки реализованной вами функциональности мы подготовили postman-тесты.

Ну вот и всё! Теперь ваше приложение умеет делать то, что нужно пользователям. При этом работает стабильно и надёжно,
поскольку весь код покрыт тестами. Также в ShareIt реализована микросервисная архитектура, а значит, его легче
поддерживать и масштабировать. Пользователи больше не будут страдать из-за проблем с производительностью и смогут
продолжить делиться вещами с удовольствием. Поздравляем!