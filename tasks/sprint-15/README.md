# Проект ShareIt. Техническое задание. Часть 2

В прошлом спринте вы приступили к проекту ShareIt и уже сделали немало — например, реализовали слой контроллеров для
работы с вещами. В этот раз вы продолжите совершенствовать сервис, так что он станет по-настоящему полезным для
пользователей.

Перед вами две большие задачи: добавить работу с базой данных в уже реализованную часть проекта, а также дать
пользователям возможность бронировать вещи.

## Немного подготовки

В этом спринте разработка будет вестись в ветке add-bookings. Создайте ветку с таким названием и переключитесь на неё.
Далее переходите к настройке базы данных. Пришло время использовать Hibernate и JPA самостоятельно. Для начала добавьте
зависимость spring-boot-starter-data-jpa и драйвер postgresql в файл pom.xml.

## Создание базы данных

Теперь поработайте над структурой базы данных. В ней будет по одной таблице для каждой из основных сущностей, а также
таблица, где будут храниться отзывы.

Подумайте, какой тип данных PostgreSQL лучше подойдёт для каждого поля. В качестве подсказки проанализируйте таблицы,
которые были использованы в приложении Later.

Напишите SQL-код для создания всех таблиц и сохраните его в файле resources/schema.sql — Spring Boot выполнит
содержащийся в нём скрипт на старте проекта. На данный момент вам достаточно создать таблицы для двух сущностей, которые
вы уже разработали - Item и User.

Важный момент: приложение будет запускаться много раз, и каждый раз Spring будет выполнять schema.sql. Чтобы ничего не
сломать и не вызвать ошибок, все конструкции в этом файле должны поддерживать множественное выполнение. Это значит, что
для создания таблиц следует использовать не просто конструкцию CREATE TABLE, но CREATE TABLE IF NOT EXISTS — тогда
таблица будет создана, только если её ещё не существует в базе данных.

Подсказка: пример кода для создания таблицы users

```sql
CREATE TABLE IF NOT EXISTS users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(512) NOT NULL,
  CONSTRAINT pk_user PRIMARY KEY (id),
  CONSTRAINT UQ_USER_EMAIL UNIQUE (email)
);
```

## Настройка JPA

Пора подготовить сущности к работе с базой данных. Мы говорили, что для этого используют аннотации JPA: @Entity, @Table,
@Column, @Id. Для поля status в классе Booking вам также пригодится @Enumerated. Добавьте соответствующие аннотации для
сущностей.
Создайте репозитории для User и Item и доработайте сервисы, чтобы они работали с новыми репозиториями.

### Подсказка: маппинг между столбцами БД и моделью данных

Если название поля в модели отличается от имени поля в базе, нужно обязательно указать маппинг между ними с помощью
аннотации @Column.

## Реализация функции бронирования

Чтобы сделать приложение ещё более полезным и интересным, добавьте возможность брать вещи в аренду на определённые даты.
Вот основные сценарии и эндпоинты:

* Добавление нового запроса на бронирование. Запрос может быть создан любым пользователем, а затем подтверждён
  владельцем вещи. Эндпоинт — POST /bookings. После создания запрос находится в статусе WAITING — «ожидает
  подтверждения».
* Подтверждение или отклонение запроса на бронирование. Может быть выполнено только владельцем вещи. Затем статус
  бронирования становится либо APPROVED, либо REJECTED. Эндпоинт — PATCH /bookings/{bookingId}?approved={approved},
  параметр approved может принимать значения true или false.
* Получение данных о конкретном бронировании (включая его статус). Может быть выполнено либо автором бронирования, либо
  владельцем вещи, к которой относится бронирование. Эндпоинт — GET /bookings/{bookingId}.
* Получение списка всех бронирований текущего пользователя. Эндпоинт — GET /bookings?state={state}. Параметр state
  необязательный и по умолчанию равен ALL (англ. «все»). Также он может принимать значения CURRENT (англ. «текущие»),
  PAST (англ. «завершённые»), FUTURE (англ. «будущие»), WAITING (англ. «ожидающие подтверждения»), REJECTED (англ.
  «отклонённые»). Бронирования должны возвращаться отсортированными по дате от более новых к более старым.
* Получение списка бронирований для всех вещей текущего пользователя. Эндпоинт — GET /bookings/owner?state={state}. Этот
  запрос имеет смысл для владельца хотя бы одной вещи. Работа параметра state аналогична его работе в предыдущем
  сценарии.

Для начала добавьте в модель данных сущность Booking и код для создания соответствующей таблицы в файл
resources/schema.sql.

Создайте контроллер BookingController и методы для каждого из описанных сценариев. Подумайте, не нужно ли написать
дополнительные DTO-классы для каких-то сценариев.

Кроме контроллеров, необходимо реализовать хранение данных — то есть сервисы и репозитории.

### Подсказка: какие могут быть изменения в DTO

Например, может быть полезно создать отдельное перечисление для возможных методов параметра state, ведь задачи этого
перечисления могут отличаться в слое представления (параметр для поиска) и в модели данных (состояние бронирования).

## Добавление дат бронирования при просмотре вещей

Осталась пара штрихов. Итак, вы добавили возможность бронировать вещи. Теперь нужно, чтобы владелец видел даты
последнего и ближайшего следующего бронирования для каждой вещи, когда просматривает список (GET /items).

## Добавление отзывов

Мы обещали, что пользователи смогут оставлять отзывы на вещь после того, как взяли её в аренду. Пришло время добавить и
эту функцию!

Добавьте в базу данных таблицу comments. Теперь создайте соответствующий класс модели данных Comment и добавьте
необходимые аннотации JPA. Поскольку отзыв — вспомогательная сущность и по сути часть вещи, отдельный пакет для отзывов
не нужен. Поместите класс в пакет item.

Комментарий можно добавить по эндпоинту POST /items/{itemId}/comment, создайте в контроллере метод для него.
Реализуйте логику по добавлению нового комментария к вещи в сервисе ItemServiceImpl. Для этого также понадобится создать
интерфейс CommentRepository. Не забудьте добавить проверку, что пользователь, который пишет комментарий, действительно
брал вещь в аренду.

Осталось разрешить пользователям просматривать комментарии других пользователей. Отзывы можно будет увидеть по двум
эндпоинтам — по GET /items/{itemId} для одной конкретной вещи и по GET /items для всех вещей данного пользователя.

## Тестирование

Для проверки всей функциональности, которую вы добавили в этом спринте, мы подготовили Postman-коллекцию — используйте
её для тестирования приложения.

## Дополнительные советы ментора

### Доработка модели данных

Новый класс Booking будет содержать следующие поля:

* id — уникальный идентификатор бронирования;
* start — дата и время начала бронирования;
* end — дата и время конца бронирования;
* item — вещь, которую пользователь бронирует;
* booker — пользователь, который осуществляет бронирование;
* status — статус бронирования. Может принимать одно из следующих значений:
    * WAITING — новое бронирование, ожидает одобрения, APPROVED — бронирование
      подтверждено владельцем, REJECTED — бронирование отклонено владельцем,
      CANCELED — бронирование отменено создателем.

### Создание базы данных

Основные поля, которые нужно создать в таблицах, в целом аналогичны полям в
уже реализованных сущностях:

* users : id , name , email .
* items : id , name , description , is_available , owner_id , request_id .
  Обратите внимание: поля owner_id и request_id — это ключи записей в других
  таблицах ( users и requests соответственно). Так будет реализована связь
  между сущностями на уровне базы данных.
* bookings : id , start_date , end_date , item_id , booker_id , status .
* requests : id , description , requestor_id .
* comments : id , text , item_id , author_id .

Обратите внимание: для хранения полей, содержащих дату, удобнее использовать
тип TIMESTAMP WITHOUT TIME ZONE . Почитать подробнее о типах данных для хранения даты и
времени в PostgreSQL можно в документации.

Также продумайте ограничения ( CONSTRAINT ) для таблиц.

Добавьте параметры доступа к базе данных в файл application.properties . Именно
их Spring будет использовать при выполнении скрипта, а также при дальнейшей
работе приложения.

Запустите проект и убедитесь, что старт прошёл без ошибок. Подключитесь к базе
данных через консоль и проверьте, что все таблицы созданы. Поздравляем —
структура базы готова! А вы готовы сохранять данные.

### Настройка JPA

Переходите к созданию JPA-репозиториев — кода, через который ваш проект будет
работать с БД. Spring Data JPA позволяет автоматизировать создание DAO-классов
в приложении — для этого достаточно реализовать интерфейс репозитория.

Начните с самого простого — с пользователя. В пакете user создайте интерфейс
UserRepository , наследующий интерфейс JpaRepository . Все базовые методы для
работы с данными, то есть чтение, сохранение, обновление, будут доступны
пользователям этого интерфейса автоматически. Теперь вы можете внедрить
репозиторий в класс UserServiceImpl и заменить реализацию хранения данных в
памяти на работу с БД.

Повторите те же шаги для item — создайте интерфейс ItemRepository и теперь уже
полноценно реализуйте в ItemServiceImpl все сценарии, которые вы наметили в
предыдущем спринте.

Большинство этих сценариев покрывается базовыми методами CRUD, однако вам
также нужно добавить функцию поиска вещи. Причём переданный пользователем
текст нужно искать как в названии, так и в описании. Этот шаг не реализуется
Spring автоматически, так что запрос для поиска придётся написать вручную.

Подсказка: как написать SQL-запрос в репозитории
Необходимо декларировать метод поиска в интерфейсе репозитория, а также
указать текст нужного SQL-запроса с помощью аннотации @Query . Например,
вот так.

```java

@Query(" select i from Item i " +
        "where upper(i.name) like upper(concat('%', ?1, '%')) " +
        " or upper(i.description) like upper(concat('%', ?1, '%'))")
List<Item> search(String text);
```

Этот код не «чистый» SQL, а SQL-подобный язык. Он работает с сущностями
модели данных, а не с полями таблицы: обратите внимание, например, на
конструкцию select i from Item i . Если имена полей модели и наименования
полей в базе данных отличаются, в запросе необходимо указать именно поля
модели данных.

Не забудьте добавить в код сервиса логические проверки: например, у
пользователя не должно быть возможности создать вещь с пустым названием.
Запустите приложение и выполните несколько запросов. Сначала создайте
пользователя. От его имени создайте новую вещь. Обновите её статус на
«недоступна для аренды» и обратно. Попробуйте найти эту вещь с помощью
поиска и посмотреть подробную информацию о ней.

### Реализация функции бронирования

Создайте интерфейсы BookingService и BookingRepository , а также класс
BookingServiceImpl — всё по аналогии с тем, что вы делали для работы с User и
Item .

Подсказка: как научить Spring генерировать нужный метод
Для работы с бронированием понадобятся более сложные запросы в
репозитории. Для части запросов придётся написать SQL-код вручную, как это
было с поиском вещи.

Также пригодится ещё одна возможность Spring Data JPA. Вы можете создать в
интерфейсе BookingRepository метод, названный по конкретным правилам, а
Spring автоматически сгенерирует его содержимое. Этот вариант полезен для
запросов, которые не покрываются стандартными CRUD-операциями, но при
этом обладают достаточно простой логикой — например, найти запись по
значению определённого поля.

```java
List<Booking> findByBooker_IdAndEndIsBefore(Long bookerId, LocalDateTime end, Sort sort);
```

Дополнительные советы ментора4Если добавить в репозиторий метод с таким определением, Spring сгенерирует
метод, который будет осуществлять поиск всех записей по переданному
bookerId с датой окончания (поле end ) раньше переданной

Запустите приложение и попробуйте создать несколько бронирований для
добавленных ранее вещей, а также подтвердить либо отклонить их другим
пользователем. Проверьте, как работает просмотр списка бронирований и
отдельного бронирования. Убедитесь, что функционал полностью работоспособен!

### Добавление дат бронирования при просмотре вещей

Сначала доработайте DTO-класс, который приложение возвращает пользователю
при просмотре списка его вещей. Добавьте в класс две записи с датами
бронирования. Обратите внимание: теперь объект вещи, который возвращается
пользователю по эндпоинту GET /items и по GET /items/{itemId} , отличается. Поэтому
правильнее будет создать отдельный DTO-класс для каждого из этих запросов.

Далее доработайте слой сервиса и репозиториев. Здесь есть ещё одна сложность:
объект Item не содержит ссылок на относящиеся к нему бронирования. Это
связано с тем, что для реализации такого хранения пришлось бы использовать
связь вида @OneToMany , у которой свои особенности. Вместо этого мы применяем
более простую связь @ManyToOne и храним в бронировании ссылку на
соответствующую Item .

Поэтому для реализации получения дат бронирования вам нужно выполнить
дополнительный запрос в репозиторий бронирований. Добавьте в BookingRepository
метод, получающий бронирования для определённой вещи. Booking содержит
ссылку на Item , так что всё получится. Вызовите этот метод внутри сервиса
ItemServiceImpl , а затем вручную добавьте в результирующий DTO-объект нужные
данные. Для этого внедрите BookingRepository в класс ItemServiceImpl .

Подобный метод часто используется при разработке крупных проектов,
поскольку получить все нужные данные из базы одним запросом бывает
либо невозможно, либо совсем неэффективно.

Убедитесь, что приложение корректно возвращает даты бронирований для каждой
вещи, и двигайтесь дальше.

### Добавление отзывов

Отзыв относится к одной вещи, а вот вещь может иметь много комментариев,
поэтому вы будете хранить в Comment ссылку на Item , но в Item ссылок на Comment
не будет. Этот пункт аналогичен тому, в котором вы реализовали связь Item —
Booking .

Таким образом Comment будет содержать следующие поля:

* id — уникальный идентификатор комментария;
* text — содержимое комментария;
* item — вещь, к которой относится комментарий;
* author — автор комментария;
* created — дата создания комментария.

Теперь дайте пользователям возможность оставлять отзыв на вещь. Отзыв может
оставить только тот пользователь, который брал эту вещь в аренду, и только после
окончания срока аренды. Так комментарии будут честными. Добавление
комментария будет происходить по эндпоинту POST /items/{itemId}/comment .

Это единственный эндпоинт для работы с отзывами — разместите его в
ItemController . Создавать отдельный контроллер не потребуется: это было бы
уместно в приложении с более продвинутым функционалом отзывов. А вот
написать DTO-класс для комментария нужно.

Добавьте в нужные DTO-объекты список отзывов. Для получения списка из БД
реализуйте обращение к новому репозиторию CommentRepository в соответствующих
методах в ItemServiceImpl . Вероятно, вам также захочется добавить в
CommentRepository новые методы для поиска комментариев к вещи.
Убедитесь, что отзывы успешно добавляются и отображаются.